1.统计算法运行时间
    a.确定运行平台，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。
    b.评估各种计算操作所需要的时间，例如加法操作 + 需要 1 ns，乘法操作 * 需要 10 ns，打印操作需要 5 ns 等。
    c.统计代码中所有的计算操作，并将所有操作的执行时间求和，从而得到运行时间。
            例如
                void algorithm(int n) {
                    int a = 2;  // 1 ns
                    a = a + 1;  // 1 ns
                    a = a * 2;  // 10 ns
                    // 循环 n 次
                    for (int i = 0; i < n; i++) {  // 1 ns ，每轮都要执行 i++
                        cout << 0 << endl;         // 5 ns
                    }
                }
            输入数据大小为 n，根据以上方法，可以得到算法运行时间为 6n+12 ns。
然而，统计算法的运行时间既不合理也不现实
        我们不希望预估时间与运行平台绑定
        我们很难知道每种操作的运行时间
2.统计时间增长趋势
    “时间增长趋势”是指算法运行时间随着输入数据大小的增加而增加的趋势。
        假设输入的数据大小为 n ，给定三个算法A, B, C。
            算法 A 只有一个打印操作，运算时间不随着 n 的增大而增大，我们称此算法的时间复杂度为“常数阶”，记为 O(1)。
            算法 B 有一个循环，打印操作循环 n 次，运算时间随着 n 的增大而增大，我们称此算法的时间复杂度为“线性阶”，记为 O(n)。
            算法 C 嵌套两个循环，第一个循环循环 n 次，第二个循环循环 n^2 次，运算时间随着 n 的增大而增大，我们称此算法的时间复杂度为“平方阶”，记为 O(n^2)。
        相较于直接统计算法时间
            时间复杂度能够有效评估算法效率
            时间复杂度的推算方法更简单
                        也存在一定的局限性
3.函数渐进上届
    设算法的计算操作数量是一个关于输入数据大小 n 的函数， 记为T(n), 则下面的算法操作数量为
                                T(n) = 3 + 2n
                void algorithm(int n) {
                    int a = 1;  // +1
                    a = a + 1;  // +1
                    a = a * 2;  // +1
                    // 循环 n 次
                    for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）
                        cout << 0 << endl;    // +1
                    }
                }
    T(n) 是一次函数，说明时间增长趋势是线性的，因此可以得出时间复杂度是线性阶。
        我们将线性阶的时间复杂度记为 O(n)。
    推算时间复杂度本质上是计算操作数量函数“T(n)”的渐进上界


        